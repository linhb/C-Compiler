1/31/12

TA section:

Makefile:
scanner.o : scanner.c scanner_token.h : compile from c and h to o

SHould have a driver file for the lex generated file b/c it doesn't have main
also a file that specifies constants
eg  #define CHAR 11

should use a test framework

Lex file:

%option yylineno # keep track of line numbers
%option nounput
%option noyywrap

Top {% %} part:
  include stdlib, errno, string (for copying strings), assert (like java assert)
  if including own file, put in "" no <>

Next part in %% %%: regexes
  eg  newline \n
  can use [[:digit:]], alpha
  {letter}: any letter

Next part:
  {newline}: can do line_number++ or do nothing and let Lex count lines
  
Reserved words
  eg  char  return CHAR # first 'char' is just the regex, 2nd CHAR is from the constants file

When returning the type eg NUMBER, can also set yyval (a static/external variable) to the value of the number, or if returning lots of info about the number, use a struct

strtoul(text, NULL, 10): string to unsigned long, 10 is the base

Can define struct number{ int i} and then have a function that returns number
To declare a variable of type number:
  num = (struct number *)malloc(sizeof(struct number));
To assign value to a struct field: 
  num->overflow = 1;
In the function that finds values of number strings, test by value if they are long or int, signed or unsigned
#define ADDNAME(ARRAY, TOKEN) ARRAY[TOKEN] = #TOKEN # this is a macro that gets the value of TOKEN in the constant file

yylex() returns either a token or 0 -> call repeatedly

Print output with line numbers:
  fprintf(output, "line = %-5d\t", yylineno)

for (token = yylex(); 0 != token; token = yylex())

Output of driver program should be a list of tokens with line numbers, types, values

Example test:
  TEST_F(ScannerTest, SlashTest) {
  fputs("/", test_input);
  fclose(test_input);
  
  EXPECT_EQ(SLASH, yylex()); # expect yylex to return the SLASH token
  }
  
Put this in a separate unit_test file


ssh lbui@nice.harvard.edu

Class

Lexer should return 2 tokens 0 and 1 for input "01"
a ^ b is not the same as (a != 0) ^ (b != 0)
a || is the same as (a != 0) || (b != 0)

Logical operators:
  a && b
  !a
  a || b
  a ? b : c
Bitwise operators:
  a ^ b
  a & b
  a | b
  ~a: complement, reverses bits
Comparison
  a == b
  a != b
  a < b
  a > b
  a <= b
  a >= b
Arithmetic
  +
  -
  * /
  % (remainer not modulo)
  a++
  a--
  ++a
  --a
  -a
Assignment
  =
  +=
  -=
  *=
  /=
  %=
  &=
  |=
  ^=
  >>=
  <<=
Shift
  a >> b (shift a's bits left b times)
  <<
Separator characters
  ()
  []
  {}
  a = b,c,d; # comma is a 'sequence point'
  ;
  :
  …

Can't rewrite a += b as a = a + b because a may have changed, as in:
  a[b++] = a[b++] + c (b will have changed)

Given
  struct node {
    int val;
    struct node *next;
  } myNode;
Then I can say myNode.val

a -> b is equivalent to (*a).b

Forward reference is the ability to reference a symbol earlier in the program text than where that symbol is declared or defined.
  Declaration vs definition:
    Declaration: storage isn't allocated
      eg int f(int x); (prototype declaration; this appears at the top of the file)
      extern int i;
    Definition:
      int f(int x) {
        return x * x;
      }
  Instance where forward reference can happen: 
    in the node struct above where node next* appears before node is done being defined.
    labels:
      void f(void) {
        goto exitCode; # forward reference
        exitCode: ...
      }
Scope: file scope (eg main()), block scope (local variables)
Overloading happens when a later definition overwrites an earlier one, or when 2 functions/operators have the same name eg postincrement and preincrement (both named ++)

Extent: length of time that storage is allocated for that variable
  void f(void) {
    static int i; // this hasn't changed the scope of i, but it changes the extent of i. i now lives for as long as the file lives, but it's still only visible in f. i is initialized to zero because it's static. If I call f recursively, the i in the 2nd f will be this i too. The opposite is auto
    C doesn't allocate and deallocate space for block variables when it enters a block. It figures out how much space the variables in a function needs when it enters the function. It does that by looking at block nesting and figuring out the maximum storage needed. IF there are 2 blocks at the same level, it takes the estimate of one that requires more memory. It also allocates the parameters at the same time.
    
    i = 35; // if you call i after f, it'll be 35
  }
  
static functions:
  static int f(void): can't be seen by other files
  int g(void): can be seen by other files
Type qualifiers
  int *p; // p is a pointer to an int.  This allocates storage for p but not the int that it points to
  p = &i; // p gets the address of i
  *p = 3; // changes what p points to
  If we have
    const int *p1; // p1 is a pointer to constant, so can't say *p1= but can say p1 =
    int * const p2; // p2 is a constant pointer to an int, so can't say p2 = … but can say *p2 = 
    const int * const p3; // p3 is a constant pointer to a constant int 

There are 5 classes of identifiers
  macros
  labels: can have the same name as a variable because it's only used after goto
  tags: what follows struct, union and enum eg the 'node' in 'struct node', also can be the same as variables
  component names: fields in structs and unions eg val in struct node above
  all other names: variables, functions, typedef names, enum constants. Every one of these requires creating a new symbol table

main isn't a reserved word; it's just a requirement of the linker


Regular expressions
  sigma: alphabet
  epsilon: a regex
  L(epsilon): language accepted by epsilon which is {epsilon}
  a is a symbol in the alphabet
    a is a regex
    L(a) = {a} 
  (r) | (s)
    L(r) union L(s)
  (r)(s)
    L(r)L(s): strings accepted by r concatenated with strings accepted by s
  (r)* 
    L(r)*
  * is idempotent: you can apply it multiple times and it'll just be like applying it once
  Ex: {letter}({letter}|{digit})*/[^a-zA-Z0-9]
  things after the slash are required to be present but aren't part of the symbol, so characters that aren't a-z, A-Z, 0-9 must follow the string but aren't part of the string
  <Fig. 1>
  
Lex
  Special characters
    ^: NOT and beginning of line
    $: end of line
    /: must be followed by
  Rules
    c matches the single no-operator character c
    \c matches the character c
    [^s]: matches any one character not in s
    r{m, n}: matches between m and n occurrences of r
    (r) matches r where r is a regex
    {name} matches the regex defined by name
  Extension .lex
  Format
    <definitions>
    %%
    <rules>
    %%
    <user functions>
  Anything in definitions section that's delimited by a line with %{}% is copied directly to the C output
  Definition section: each line has format <name><regex>. MUST NOT HAVE SPACE BEFORE REGEX!
  The kind of token gets returned
    Things with the same precedence can be returned together eg multiplicative_operator
  The value of the token gets placed in yylval
  
  
  Compiling a Lex file
    lex lexer.lex
    gcc lex.yy.c -c // -c means create an object file, but don't link
      object file will have .o extension
      returns lex.yy.o
    gcc -pedantic -Wall lex.yy.o lexer.c -lfl -o lexer
      pedantic means ensure standard compliance
      Wall: issue all warnings
      lfl: link with the flex libraries
  Special symbols (mostly for use with yacc):
    yytext: the matched string as a null terminated string
    yyleng: length of yytext
    yylex(): name of generated lexer function
    yylval: value of the token returned
      What type should it be? struct or union if needed
  Sample Makefile on course website
  Lex always prefers longer string match to resolve ambiguity
  If 2 matches match strings of the same length, Lex will pick the one that comes earlier in the .lex file
  
lvalue and rvalue: when you have eg int a = 3, there are 2 relevant values, 3 and a's memory address
  lvalue is the memory address, retrieved with &
  rvalue is the value 3, retrieved with *

#define is a preprocessor
union: like struct in most ways except can only call 1 field at a time (they're stored at the same address). Good for variables whose value can only be 1 of several types.

&: address-of operator (mnemonic: address-ampersand)

strcmp(str1, str2) returns 0 if the strings are equal, 1 if str1 is lexically larger (alphabetically behind) str2, -1 otherwise

2/7/12
TA section:
yylex() must return all info asked for

At the very end of rule definitions in lexer.l, can do
	.	return -1;
	This will catch every token that didn't match any above, then you can test if token < 0 to output errors

Treat everything strictly according to their appearance eg star, not what they could mean.

Identifier limit 31
String: just check memory was successfully allocated
Should return a unique number for every operator
Make int and long different tokens based on rule: it's the first type that it fits in this list: int, long, unsigned long

Have make clean target

make clean before submitting

Run script in hw1 directory, do some manual testing, Ctrl D when done

Submitting:
	submit libe295 1 <absolute path to hw directory eg ~/hw1>
	
Don't submit irrelevant files like .git

Can submit multiple times.

Add token type for comments

Lecture:

Problem set 2:

Lex program that works with YACC:
	
Goal: build a tree
	output must look like input but with treelike annotations, as proof that parser parsed the input and formed a tree
	no need to build symbol table
	just make a copy of every string you find
	things that belong to the language should be abstracted into a node
	only things the user specifies should be made strings (identifiers, etc)
	If no signed modifier, assume signed
	void can be return type or parameter, no void pointers
	no pointer to functions
	function can either always return something or implicitly return int when not specified
	no declarations without definitions except function prototypes. Prototype param list doesn't need to resemble actual signature.
	must have any level of pointers, any dimension of arrays
	should say approx line number 
	variables can only be defined once, at any scope, except functions which can have prototypes

Example of tree:
	main() {
		int lhs, alpha, beta, gamma;
		lhs = alpha + beta * gamma;
	}
	<Fig. 2>

+ and * nodes don't have to be different kinds of nodes if you specify the precedence

There's a grammar on the website that can be parsed into a grammar

Don't have every production as a node

YACC format:

<declarations>
%%
<translation rules>
%%
<supporting C functions>

<declarations> have all the constants currently in token_constants.h
	everything between %{ and %} is copied into output, so should have prototypes for supporting functions
	Each line in declarations
		%start <nonterminal>
		%token <listOfNames> // list of tokens having the same precedence
		%left <listOfTerminals>
		%right <listOfTerminals>
		%nonassoc <listOfTerminals>
	Precedence: in order of declaration, lowest first
	Translation rules:
		<head>	:	<body1> {<semantic action 1>}
						| <body2> {<semantic action 2>}
						;
	single quoted char is terminal symbol
	$$: attribute associated with head
	$i: attribute of ith symbol
	unquoted strings not declared to be tokens are nonterminals
	in reduce conflict, 1st one listed wins
	shift wins over reduction
	tries to take care of as many tokens as possible
	default precedence of a production is that of its rightmost terminal
	
	#include lex.yy.c in 3rd part of Yacc file ()
	the tokens in the yacc file actually get declared first, before lex
	
	DIfference from standalone version of lexer:
		YYSTYPE: macro indicating the type you want yylval to be
		struct node: have fields for all types of info the nodes should have, enum type, *operator, node *left, *right, int val. Nodes will need to say the base type of pointers for later type checking.
		have print_tree function
	Translation rules
		a : b: a can be rewritten as b
		More rules => less precedence to worry about and vice versa
	Output: has node type, addresses of children so we can reconstruct the tree
Dragon app for recording?     c
How to tell if i have an expr if the rule for expr is expr + term | term
	Yacc tries to match the longest string
	a method that looks for expr will look for it first thing every time it calls itself, so it'll recurse forever, hence 'left recursive' language
	look at rule for factor: (expr) | number -> if doesn't start with ( or number, not a factor
	To avoid left recursion, 
		if a: a | b
		rewrite:
		a: b a'
		a': a a' | epsilon
		This however doesn't produce a correctly balanced tree as in Figs 3, 4. In Fig 4, the tree is right associative, while the language is left associative
		
2/14/12
TA section
Pretty printer
	basically print source program but with indentation and parens around everything that can use parens (required)
	regularize indentation
	parenthesize everything
	print escape sequences 
	to print binary ops: print ( then left operand then space then right operand then )
	can have all the parens you want especially to clarify precedence
	good test: feed program in, get output, put output in, should get itself
	all functions take int indent, increment whenever you enter new scope
	can use phpsyntaxtree to visualize
main functions is the same as lexer
	call yyparse, get 1 value
	yyparse sets yynerrs
	if >0, set result to 1
parser
	yystype is node*
	default action is $$ = $1 (the thing returns from the first symbol)
	example of non default: left_paren expr right_paren: $$ = $2
	global var root_node so you can get it back
	$$ is yylval?
	can use union type for node, can be number, identifier etc, each of which is a struct with specific fields. These can be defined in node.h
	the actions create node*'s
	the specific node creators call create_node to malloc
statement_list node: has 2 children, left one expands into the another statement_list and the 3rd from last statement, etc. Then you traverse the node recursively to print. one of the bottom statement_list nodes will have NULL as a child because it only contained 1 statement
	yylval is what was returned by yylex(), so when you assign the value of a terminal to the value of a production ($$), $$ will end up being the same as yylval. $$ and yylval do have to be the same type.
error
	error production: error SEMICOLON -> means if you see error, keep scanning until you see a semicolon. If you don't have this production, the parser will exit when it gets an error.
	Bison knows that if lex returns -1, it's an error
	implement yyerror(char *msg) which Bison calls automatically when it gets an error
epsilon: 
	pass NULL to creator function eg parse.y:59
statement vs expression:
	statement can have operators, can be an expression
compound statement = block

Lecture

Updated PS1 and HTML grammar
Recursive descent = top down = predictive

Predictive parsing: 
	2 important functions: first and follow
Generate NFA   from regex:
	ba*b(a|b)a
	Fig 5                             
	epsilon-closure(state): all possible states you can be from state based on transitions alone
	epsilon-closure(set of states): union of ES of each state in the set
	If building algo to find ES, have to keep a set of states to check for epsilon paths coming out of them, because some results can be reached with >2 epsilon transitions
Build DFA from NFA:
	notebook
How parsers work
	notebook  
Generating grammars
	ba*bba
		Ao => bA1bba
		A1 => aA1 | epsilon # basically break down parts of the regex that aren't static into rules
	if (if...() endif) endif
		so => if S1 endif S1
		S1 => S0 | epsilon
		Not possible with regex
	stmt -> if expr then stmt |
					if expr then stmt else stmt |
					other
		ambiguous eg if e1 then if e2 then s1 else s2
		Fix:
			stmt -> matched-stmt | open-stmt
			ms -> if e then m-s else m-s | other
			o-s -> if e then stmt |
						 if e then m-s else o-s # this says only m-s can be between if and then, and m-s is defined above to have else bound to the correct if
Fixing recursive productions:
	notebook

First and follow functions
	Non left recursive grammar for + and *:
		E -> TE'
		E' -> + TE' | epsilon
		T -> FT'
		T' -> * FT' | epsilon
		F -> (E) | id
	first(alpha): set of terminals that can appear as the first token in alpha. Can include epsilon
		if X -> Y1Y2...Yk
			then first(X) will include first(Y1)
			if first(Y1) includes epsilon then first(X) includes first(Y2) (makes sense b/c that means Y1 can disappear leaving Y2 at the top)
 	follow(nonterm): set of terminals that can follow any sentence derived from nonterm
		useful for error recovery: can look for a symbol in follow if error found, thus terminating erroneous string
		the follow set for the start symbol should always include the endmarker $ because it definitely follows the topmost nonterminal
	
	alpha	first(alpha)	follow(A)
	+    	{+}
	*    	{*}
	(    	{(}
	)    	{)}
	id   	{id}
	---
	E    	{(, id}	    	{), $}
	E'   	{+, epsilon}	{), $}
	T    	{(, id}     	{+, ), $} # everything in first(E') except epsilon should be in follow(T) because E' follows T
	T'   	{*, epsilon}	{+, ), $}
	F    	{(, id}     	{*, +, ), $} 
	
Now we can automatically construct a recursive descent parser:
	LL(1) grammars:
		L1: left to right
		L2: leftmost derivation
		1: token of lookahead
	Build predictive parsing table M:
		Grammar again, numbered:
			E -> TE' (1)
			E' -> + TE'	(2) | epsilon (3)
			T -> FT' (4)
			T' -> * FT' (5) | epsilon (6)
			F -> (E) (7) | id (8)
			
		
		Nonterm 	id			+   			*			(					)							$
		E	      	E->TE'						 			E->TE'
		E'      					E'->+TE'									E'->epsilon   E'->epsilon
		T	      	T->FT'						 			T->FT'
		T'      					T'->eps		T'->*FT'				T'->eps				T'->eps
		F	      	F->id 						 			F->(E)
		
		Example: (id + id) * id + id $
		Looking for E, see (, look into table at E and (, 
		
		Matched			Stack				Input								Action
		            E$        	(id+id)*id+id$
		            TE'$     	 	''                  E->TE'
		            FT'E'$   	 	''                  T->FT'
		            (E)T'E'$ 	 	''                  F->(E)
		(           E)T'E'$	 	 	id+id)*id+id$				match (
		            TE')T'E'$	 	''                  E->TE'
		            FT'E')T'E'$ ''                T->FT'
		            idT'E')T'E'$ ''               F->id
		(id         T'E')T'E'$ 	+id)*id+id$        match id
		            E')T'E'$    ''                T->eps
		            +TE')T'E'$  ''                E'->+TE'
		(id+        TE')T'E'$   id)*id+id$        match +
		            FT'E')T'E'$ ''                T->FT'
		            idT'E')T'E'$ ''               F->id
		(id+id      T'E')T'E'$  )*id+id$          match id
		            E')T'E'$    ''                T'->eps
		            )T'E'$      ''                E'->eps
		(id+id)			T'E'$       *id+id$           match )
		            *FT'E'$     ''                T'->*FT'
		(id+id)*    FT'E'$      id+id$            match *
		            idT'E'$     ''                F->id
		(id+id)*id  T'E'$       +id$              match id
		            E'$         ''                T'->eps
		            +TE$        ''                E->+TE
		(id+id)*id+ TE$         id$               match +
		            FT'E$        ''               T->FT'
		            idT'E$       ''               F->id
		(id+id)*id+id T'E$          $             match id
		            E$                            T'->eps
		            $                             E'->eps
		
2/21/12

TA section:

can declare error at the statement level

How to escape strings:
input "hello\n"
should convert into char array {'h', 'e', 'l', 'l', 'o', 10, 0} where 10 is the ASCII code for \n

Lecture:

Types:
	generate a symbol table for each scope
	All identifiers in the parse tree must be replaced with the right pointer into the symbol table
	A C type can be integral, floating-point, pointer, array, structure, union, function or void type.
	Integral and FP are arithmetic and scalar. Pointer is scalar.
	Array and structure are aggregate
	Symbol table:
		type		variable
		int			i
		int			j
	int pointers will have a type of pointer that points to the base type int
	& creates a pointer variable
	Pointers can be object, function or void pointers
	void * is a generic pointer which can't be dereferenced unless it's cast
	null pointer is equiv. to the integer constant 0
	Array type representation: number of elements field, base type field
	Note: arrays are really a pointer of the type of its elements, so if you say int p = A p actually gets the memory address of A's first element.
	Exception: sizeof(A) gives the actual array size. So you can get the size of A by sizeof(A) / sizeof(A.length)
	&A is the same as A
	Arrays can be any type except void, incomplete type (not done defining), function type
	always have 0 origin
	Multidimensional arrays are stored in row-major order (adjacent elements in memory differ by 1 in their LAST subscript) 
		eg: int A[2][3]: the whole thing, all 6 ints, have to be stored contiguously
		A is stored as 2 arrays of 3 ints each
		Memory layout of A:
			k			A[0][0]
			k+4		A[0][1]
			k+8		A[0][2]
			k+12	A[1][0]
			k+16	A[1][1]
			k+20	A[1][2]
	The subscript operator has the highest precedence
	A[k] is the same as *(A+k)
	Conversion of array to pointer happens for multidimensional arrays as for singly dimensioned arrays, but only for hte top level array-ness
	A = T[i][j][k] is converted to a pointer to T[j][k]
	
	enum types: integer values represented by identifiers
		type int
		ex: enum boats {power, sail, finghy} boat1, boat2;
	struct
		We can refer to struct node within struct node because pointers are allowed to refer to incomplete types 
		ints in structs have to be on addresses that are multiples of 4, etc, (aka alignment), so structs may contain holes in their storage allocations.
		components are laid out in the order they're specified
		bit fields may be specified for components in structs:
			structs DiskReg {
				int ready:1; // now ready can only occupy 1 bit so it can only be 0 or 1
				int error:1;
				int track:9; // track can be between 1 and 511
			}
	union
		storage is allocated for all components starting at the beginning of the union, so all components have the same address as the union
		If you define a field then access another field, there's no telling what you'll get back?
		vs casting:
			myStruct.f = 3.14;
			i = myStruct.i; // gets 4 bytes from the address of myStruct.f and make it an int, equiv to *(int *)&f
			i = (int) myStruct.f; // this will truncate the value so you'll get 3
	function
		can't return arrays or functions, but can return pointers to arrays and functions
	minimum precisions:
		char: 8 bits, etc
	integral number representation:
		integers:
			unsigned: 
			4 ways to represent sign:
				sign and magnitude: if having 16 bits
					1st bit: sign, 0 = pos, 1 = neg
					other 15 bits: 0 to 2^15 - 1
					value = -1^sign bit * 15 bits
					problem: 
						2 representations for 0, eg 0000 and 1000 for 4 bits
						numbers don't go in counting order: 1111 is -7, 0111 is 7, which means adding 1 is tricky: 
							1001 is -1, 1010 is -2, so to go from -1 to -2 you have to add 1
				one's complement
					the negative version of a number is its bitwise complement
					eg 0111 is 7, 1000 is -7
					can now add numbers the same way for + and - numbers
					problem: 
						still 2 values for 0: 0000 and 1111
				two's complement
					to get the negative version, complement the number then add 1
					thus the most significant bit is 1 for negative, 0 for positive
					eg: 1 is 0001, -1 is 1110+1 = 1111. This works both ways: ~(1111)+1 = 0001
					now the negative of 0 is ~(0000)+1 = 0000
				excess notation
					if you want a lot of positive numbers, pick a bias, eg with 4 bits, pick a bias of 4. Now 0 is represented as -4, 1 as -3, etc. This way you can have numbers from 4 to 15 while the representation is 0 to 11.
		floating point numbers
			sign bit (0 for positive, 1 for negative)
			exponent
			mantissa/significand/fraction
			Floating-Point Number Representation
			IEEE 754 Floating-Point
			• Size = 32 bits (float), 64 bits (double)
			• Radix = 2
			• Sign bit field
			• Exponent field = 8 bits (float), 11 bits (double)
			• Fraction field = 23 bits (float), 52 bits (double)
			• Bias = 127 (float), 1023 (double)
			• Zero value representation has exponent field = 0, fraction field = 0
			– Can be positive or negative
			Normalization
			• A normalized number has f1 > 0, if x is not 0
			• A subnormal (denormalized) number is non-zero, has e 
			= emin
			and f
			1 = 0
			– Exponent is -126 (float), -1022 (double)
			• An unnormalized number is non-zero, has e > emin
			and 
			f
			1 = 0
			• A subnormal number is too small to be normalized
			• Hidden bit
			– For normalized numbers, there is an assumed single 1 bit 
			to the left of the binary point
			– Gives one more significant bit
		On the number line, FPs aren't spaced equally.
		Special Values
		• Infinities
		– Positive
		– Negative
		– sign = 0 for positive infinity, 1 for negative infinity; 
		biased exponent = all 1 bits; fraction = all 0 bits
		• NaN’s                                       
		– Quiet
		– Signaling
		– sign = either 0 or 1; biased exponent = all 1 bits; 
		fraction = anything except all 0 bits (because all 0 bits 
		represents infinity)
			
2/28/12

TA section

% expect 1 tells the parser to expect 1 shift/reduce conflict so the error will be suppressed

Ex 4.6.2 (p258)
First(S) = {a}
Follow(S) = {a, +, *, $}
I0: closure of starting symbol
	S' -> .S
	S -> .SS+
	S -> .SS*
	S -> .a
	| a (on input a)            |
	v                           v
I2:                        I1:
	S -> a.                    S' -> S.          $
                     <--     S -> S.S+         -> accept
                      a      S -> S.S*
                              | S
                              v
												I3   S -> SS.+                +
				                     S -> SS.*  <__           -> I4: S -> SS+.
														 S -> S.S+    |  S        *
				                     S -> S.S*  ---           -> I5: S -> SS*.
														 S -> .SS+
				                     S -> .SS*                               

Fig 6 (small notebook)

Type tree for functions: Fig 7 

Must be able to indicate the declared type is different from the real type.

Lecture

if same identifier with different names, can print memory address or anything to show they're the same.

Can print the original declaration with comments showing its row in the symbol table

int glob_i; // symbol table here, must have glob_i and f
void f(int param) {  // symbol table here, must have 2 entries, for the function and the int. basically block scope with the function
	int func_i;
	{
		int block_i; // symbol table here with only 1 entry
	}
}

The data structure can be anything that lets you access all the info you need.  
No need to make sure subsequent entries are at higher memory addresses.

Type tree example: Fig 8
                                                                            
You can remove all terminals.                                                        
There'll be only 1 int and 1 void that all instances in the tables point to.

PS4: add casts
	int i;
	char c;
	i = c;
	in PS3, pretty print that as (i = c);
	in PS4, (i = ((int)c));  May need more than 1 cast 

Errors must now ?
Must catch duplicate declaration.
Must show which symbol table the identifier is bound to.

By PS4 all errors must have come out.

How to represent numbers:
	13
		-1^0 * 1.101 * 2^3
		010000010101...0(20 zeros)
	1.625
		-1^0 * 1.101 * 2^0
		0011111111010..0(20 zeros)

Another shift-reduce example: Fig 9                    

Casting:

integer <-> pointer
integer -> void *
anything -> void *

Usual assignment conversions:

any number type can be assigned to any other number type
0 or pointer can be assigned to void * or compatible pointer

Unary conversion: keep them signed if possible (if the values are small enough) (according to HS p197)
	unsigned short us;
	us = 0;
	if (us < -7) {} // us will be converted to int

int * const p1;
const int *p2; 
p1 = p2 //no
p2 = p1 //yes

3/6/12

Note: labels can have the same name as another variable in the same function, so must create a separate ST at function level for labels

Should add field in identifier struct that contains pointer to ST entry

Create child ST whenever sees compound statement   

Children must have pointer to parent so you can access global vars from blocks

Input:
	int a;
	char *b;
	long z[5];
	int main(int argc, char *argv[]);
	void c(void) {
		char a;
		for (a = 0; a < 5; a++) {
			long c;
			c = z[a];
		}
	}

	Create global ST: global
		map from names to symbols, which have name, type
		list of child symbol tables
		
		Sample output:
		
		global
			symbols
				a -> {a, 1, int}
				b -> {b, 2, pointer(char)}
				z -> {z, 3, array(5, long)}
				main -> {main, 4, func(int, 2, [int, array(?, pointer(char))])}
				f -> {f, 5, func(void, 0, [])}
			children
				f
					symbols
						a -> {a, 6, char}
					labels
						inside -> {inside, 8, b = 0 (basically pointer to the statement, print as "line 10")}
					children
						block1
							symbols
								c -> {c, 7, long}
		Also, when printing parse tree, instead of printing 'int a', print:
			int a /* symbol 1 */
			int b /* symbol 2 */
			c /* symbol 7 */ = z /* symbol 3 */[a /* symbol 6 */]
			
Errors I have to declare: 
	undeclared variable: must go all the way up to global ST, then declare error, then keep walking the tree, BUT DON'T PRINT IT			
	don't have to check if prototype doesn't match function signature
	something like int f(void, int argc);
	void x (but void *x is ok!)

If function has arguments, have to enter them in ST too

Lecture

Midterm: up to chapter 7, more emphasis on earlier stuff, no chapter 6

Memory management:
	Allocate memory at function entry, deallocate at function exit -> there is shared memory between subblocks
		int glob_i, glob_j;
		int f(float param_f) {
			int i;
			{
				int j;
			}
			{
				int k;  // k shares the same memory as j, which is ok because their lifetimes don't overlap
			}
		}
		void g(long l) {
		
		}
		void main(void) {
			f(3.14f);
		}
		
Stacks:
	'top of stack' is actually the lower memory
	the lowest memory  memory is for the program, aka 'text' as opposed to data
	next level is static/data segment: global variables
	next is heap storage eg malloc, new, etc
	
Stack frame:
	
	When main is running and about to call f, first evaluate the parameters, which is 3.14. 
	
	low			
	        **** stack frame (activation record) for f ****
	        callee saved registers
					temporaries                    
	        local vars
	        return address, which is a pointer into the place in the program immediately after calling the current function (f)
	        link to old frame pointer (FP). The FP register contains the address of the frame that current function is called from. When you enter a called function, the caller's FP (old FP, main) is saved here so you can get back to it.
	        saved registers by caller (main) to comply with conventions that help functions find parameters, etc in the same place consistently
	        f return value (int) (uninitialized)
	        f's parameters (3.14f)
					**** end stack frame for f *****
	high		
	
Later called functions have their stack frame put on top of the current stack frame

The FP is offset 0. Everything is called in terms of offsets from the FP, eg return address is -4. If local vars take up eg 12 bytes, they'll be eg offset -8 to -15.
	eg: in
	int f(float param_f) {  
		// return address -4
		int i; // offset -8
		{
			int j;         // -12
		}
		{                
			int k;  // -12 because they occupy the same memory
		}
	}
How to know how much memory to allocate: look at all the symbol tables for that level and down. If >=2 blocks at same level, take the max. So block 1 above takes 4 bytes, block 2 takes 4, so total 4, plus local variable i, so allocate 8 bytes. Since storage starts at -8 (?), f's storage takes up bytes -8 to -15.
Since f returns int, f's return value is at +4. f's parameter (3.14f) is +8.
If language allows functions inside functions, the stack frame can be adjusted:
	add a pointer called 'access link' into the bottom level function stack frame that points to the FP of the parent function
	
Heap management
	Heap:
		heap and stack grow toward each other: heap grow higher, stack grows lower
		allocation is arbitrary
		static
			eg addr = malloc(bytes)
			free(addr) // doesn't guarantee memory is actually freed
			You can have alternating spaces that are allocated and free which means no space for big objects
			can't just compress by moving everything to lower addresses b/c the memory chunks may contain their own address 
			To allocate, can look through free chunks to find lowest size chunk that fits (best fit) but this is bad b/c the space that's not taken up is useless
			worst fit (largest chunk left over) is better b/c another big allocation can be made from the leftovers
			first fit: first chunk that fits
			next fit: next chunk from last allocation
Automatic allocation:
	Reference count model: every time you create a pointer, it counts how many things point to it. When count == 0, system frees it
	Garbage collection: recursively 'reach' every object. anything not reached is cleaned up.
	Compaction: move stuff to lower spaces
Assembly language:
	32 registers, 0 to 31, treated the same in the instruction set except register 0.
	register 0 is the constant 0 (can't save to it), can be used to throw away values.
	register 1 is reserved for the assembler b/c there are instructions that aren't native to the hardware (pseudoinstructions) so the assembler needs a register to emit multiple instructions for them.
	uses three-address code -> can save to R0 if don't need to save result of operation
	some instructions are pseudo (not hardware) instructions eg 'neg'
	v0, v1 can store results of functions where they fit in 2 registers
	a0-a3: arguments
	t1-t7: temporary (saved by caller), not preserved across calls. Function has to save t values before calling another function or it may be overwritten.
	s0-s7: saved temporary (saved by callee), preserved across calls (ie still accessible after a function exits). If a function alters a s register value, it has to restore it before exiting
	stack pointer
	frame pointer
	return address
	Format of the add operation:
	add rd, rs, rt
		000000 rs rt rd 00000 100000 (ADD)
		  6    5   5  5   5     6
		31                         0
		Note the 5 bits can represent 0-31, so the 5 bits in rs, rt, rd in the ADD instruction is the register number that holds the operands/results
		MIPS is a load-store architecture, so the only way to access user-defined variables in RAM is LOAD and STORE instructions. Everything else is between registers only.
		If a number is small enough, you can embed it in the instruction itself eg
	addi
		001000 rs rt immed (immed occupies the 16 bits not occupied by the immed opcode and rs, rt. rs and immed are added and the result stored in rt)
		addi vs addiu: addi throws overflow exception, addiu doesn't
		same difference between add and addu
	Accessing memory:
		loading:
			lw rt, offset(from base register): load word
				100011-register number of base, register number of rt, offset (16 bits)
				Takes offset as a signed number, add it to base to obtain memory address, read contents of that address into rt. This address must end with 00 to end on a word boundary, otherwise get address error exception.
				To load stuff from memory, call lw with $fp and an offset.
				Also available: lh (load halfword), lhu (load halfword unsigned - what fills the register?), lb (load byte), sw, sh, sb (storing from registers to memory)
		
3/27/12

TA section:

can have int (a[]) {} but not int a[] without size, because in the first case you're passing a pointer to an int to the function, but in the 2nd it needs a size to allocate space.

Functions can return pointers to arrays but not return arrays.

If array size is a const expr, evaluate it. If it has non-numbers, emit error.

Functions can't be function parameters.

parameters must have names if not a prototype

Function identifiers can appear twice, once in prototype, once in implementation.
But functions with same name and different signatures are not allowed.

Lecture:

Intermediate code generation 
Won't be particular to any computer.
No need to optimize for efficiency.
Use three-address code (quadruples, opcode + result + 2 operands), but not every IR node needs 3 addresses.

Every time you need a subresult, use a brand new T register. Use _t or __t notation, doesn't matter b/c it's internal to the IR. Create a temporary for every IR node.

2 operands have to be same sign. Can carry sign in the temporaries (not good) or put sign in opcode, eg 'less than signed' and 'less than unsigned'. 

No need for some opcodes eg 'less than signed halfword' because doesn't exist in this language.
Also don't need eg 'signed load word' because load just loads all bits, no need to know sign.

Labels and gotos: have to insert into IR nodes, eg in if statements. Labels should be pointers to the relevant IR node. 

The only instructions that involve user defined identifiers is LOAD and STORE. Everything else, adding, branching, etc uses temporaries. 

When evaluating a statement, for lvalues we only need the address, for rvalues we only need the value.
Recommend treating everything that can be an lvalue as an lvalue until you find out it's an rvalue. eg in a = b, treat b as an lvalue, until you see the =, then dereference b to get the value.
Tag every temporary with whether it's lvalue or rvalue.

nop (no-op): IR node that does nothing (doesn't generate code)

Example:

l: a = b + c * d;
goto l;
all ints

tree:
	=
		a
		+
			b
			*
				c
				d

(nop)      *1
(loadword, t1, c)                   // would be loadByte if c were a char
(loadword, t2, d)
(multsigned, t3, t1, t2)
(loadword, t4, b)
(add, t5, t4, t3)
(storeword, a, t5)
(goto, *1)  // in this case, the label came first so i can just refer to it, but if the label came later in the code, i'll need to do backpatching, ie when i see the label, go back and mark wherever it's used where the labeled line is so it can go there. 

How to call a function:

i = f(a, b);

(loadword, t6, a)
(loadword, t7, b)
(paramword, t6) // can put t6 on the stack
(paramword, t7) 
(call, t8, f, 2) // 2 means 2 parameters, must match number of paramword
(storeword, i, t8)

(returnword, t9)

b = a[i];
|||
b = *(a + i);
|||
b = i[a];

(loadAddr, t10, a)
(loadword, t11, i)
(loadConst, t12, 4)
(multUnsigned, t13, t11, t12)
(add, t14, t10, t13)
(loadwordIndirect, t15, t14)
(storeWord, b, t15)

(castFromHalfWordToWord, t16, t17)

if (a < b) {
	c = d;
}
else {
	e = f * g;
}

{loadWord, t18, a}
(loadWord, t19, b)
(lessThanSigned, t20, t18, t19)
(ifFalse, t20, labeltemp_1)
(LW, t21, d)
(sw, c, t21)
(goto, labeltemp_2)
labeltemp_1: (nop)     	
(lw, t22, f)
(lw, t23, g)                                                    
(multSigned, t24, t22, t23)
(sw, e, t24)
labeltemp_2: (nop)

optimize:
if (a + b) * c + (a + b) *d
can reuse the temporary for a + b

a = A[i];

(loadAddr, t1, a)
(loadAddr, t2, A)
(loadAddr, t3, i)
(loadConst, t4, 4)
(loadWordIndirect, t8, t3)
(multSigned, t5, t3, t4)
(add, t6, t2, t5)
(loadWordIndirect, t7, t6)
(storeWordIndirect, t1, t7)

4/3

Lecture:

Words are 32 bits (write most significant first, so 31 - 0)
Instructions: 3 classes
	I-Type
		op			rs		rt		immediate
		31		  25    20    15      0
	J-Type (jump)
		op			target
		31-26   25-0
		6				26
	R-Type
		op		rs		rt		rd		re		function
		31    25    20    15    10    5
		
Real instructions:
	ADDU: R-type
		000000 rs rt rd 0...0 100001
		addu rd, rs, rt
	ADD: like ADDU but exception on overflow
	
	ADDIU: I-type
		001001 rs rt immediate
	ANDI
	ORI
	XORI
	
	LUI

4/9/12

Instructions aren't stored in registers, just its generated data.

4/10/12

TA:

int a, b, c;
b = 1;
a[b++] = b++;


Memory allocation:

void f(int a) {  //a: offset 4 b/c parameter
	int b;   //b: -4 because local variable
	b = 1;
	{
		char b;  //b: -5
		b = a;
	}
	{
		long c;         //c: -8
		c = a;
	}
}

Can optimize memory by packing all the word-size variables together, all the halfword-size variables together etc.

Labels: 

void f(void) {
	while (expr) statement;
}

while0: nop
	expr -> t0
	ifFalse t0, while1
	statement
	always while0
while1: nop

Should put suffixes on labels to make sure they don't conflict.

Adding to pointers:

int *p;
int a[5];
p = &a[0];
*(p + 1) = 3; // changes a[1]
when adding/subtracting from a, make sure to a/s the added amount * the size of the base type                             
	eg if base type is an array of 5 chars, p+1 should really be p+5


Casting:

short a;
unsigned short b;
a = (short) (+(int) b);

la t0, b
la t1, a
lhiu t2, t0 // needs the 'u' so that lh will do the sign extension
// now t2 is already word sized, so already an int, no need to do more to make b an int
castUStoI t3, t2 // doesn't do anything
castItoS t4, t3 // should mask to remove higher 16 bits, so "AND t4, t3, 0xFFFF"
sh t1, t4 // store half

Lecture:

Problem set 6:

generate MIPS assembly language:
	don't combine 2 IR nodes
	don't optimize
	use graph coloring algorithm to reset register numbers eg at the start of each statement
	can use built-in functions eg print_int, print_string etc, probably mapped to own functions
	
Final working compiler counts more than individual PSes.

Can use pseudo instructions (with daggers in doc) but they'll probably generate >1 instructions.


BGEZ: branch if >= 0
000001 rs BGEZ/00001 offset
Branching is relative, taking the offset, shift left 2 bits (make it a word boundary, and making 2 more bits available to the range of the offset), sign extend (make 14 copies of the 15th, ie the most significant bit, helps to branch both backward and forward), add that to the address of the next instruction (aka PC, which we can't see), thereby telling it to go forward or backward
also BGEZL: L = likely, more likely to branch than not branch -> prefetch the branch -> faster
Assume all branches are close enough to use branch instructions

Also: BGTZ, BLTZ, BLEZ

BEQ: takes 2 registers, branch of equal. Difference: opcode is in 6 most significant bits:
	000100 rs rt offset
	
16 bit offset has range (-32k, 32k - 1)
-> lots of room to branch, but if needs more:
JR (jump through register): eg JR $s0: the address to jump to is in register s0 -> now you have a range of -2^32, 2^32 - 1 to branch to
	format: rs opcode

J (jump) target: larger range than the BG family of instructions, but doesn't need a register
	000010 target address (26 bits) (target is also concat with 00 to gain 2 more bits, then prepended with the 4 high order bits of the address of the next instruction (PC))
	
JAL: jump and link (leave behind a return address)
	same as J but writes return address to r31 (aka ra, last general-purpose register - the only other special register other than "zero")
	
JALR: jump and link register, like JR but can specify 2 registers, so can put return address in any register, doesn't have to be r31
	rd (return address), rs (register that has address we're branching to)

BLTZ: branch on <= 0: $s0, new_label
J label -> jump to label on <= 0
new_label: ...

BLTZAL, BGEZAL: the -and link versions, but the other 2  have no and link version b/c ran out of opcodes 

Shifting:
logical shifts: put 0s in freed up bits
arithmetic shifts: maintain sign bit
SLL: shift left logical constant, so shift amount is in the instruction itself
	rd (destination), rt (source), sa (shift amount, can only be 5 bits)
SRL
SRA

SLLV (v=variable, ie what's in rs will be the number of bits to shift by) 
	rd, rt, rs (shift amount - only lowest order 5 bits are used, so shift max 31 bits, so basically mod 32)
SRLV
SRAV

Multiply instructions:
MULT: treat operands as 32 bit 2's complement numbers, lower order bits stored in LO, higher stored in HI -> 64 bit result, then can use MFHI and MFLO (move from HI/LO, rd, moves those bits into rd)
	rs, rt
DIV: quotient word of result is put in LO, remainder put in HI
	rs, rt -> rs/rt
MTHI/MTLO: opposite of MF

SPIM has eg DIV rd, rs, rt which does the MF for you

To move, OR rdest, zero // OR the source with 0, then put in destination

Sample programs:
	all data needs to be in .data section
	all text needs to be in .text section
	can go back and forth by having .data again to re-enter .data
	needs that b/c .text isn't writable
	.word initialize the first word?
	.globl: can only have 1, should be called 'main', doesn't have to be 1st instruction
	
	print int:
	
			.data
		count:	.word	45        // initialize .word to 45

			.text
			.globl	main
		main:	li	$t0,97         // overwrite .word with 97
			sw	$t0,count	# zero count

			li	$v0,1		# v0 <- syscall code for print_int     
			lw	$a0,count	# a0 <- int to print
			syscall			# print count                         // should print 97, no newline

			li 	$v0,10		# v0 <- syscall code for exit
			syscall
		
	print string:
	
			.data
		hello:	.asciiz	"Hello world!\n"          // .asciiz is an instruction, translates each char into a byte, store in hello, 'z' will null terminate

			.text
			.globl	main
		main:	li	$v0, 4		# v0 <- system call code for print_string
			la	$a0, hello	# a0 -> hello string // loads into a0 the pointer to the string 'Hello world\n'
			syscall

			li	$v0, 10		# v0 <- system call code for exit
			syscall
		
	count:
	
			.data
		count:	.word	1
		countstr:	.asciiz	"The current count is "
		newline:	.asciiz	"\n"

			.text
			.globl	main
		main:	li	$t0, 0
			sw	$t0, count         //reset count to 0

		loop:	li	$v0, 4		# v0 <- system call code for print_string
			la	$a0, countstr	# a0 -> count string
			syscall

			li	$v0, 1		# v0 <- system call code for print_int
			lw	$a0, count	# a0 <- the current count
			syscall

			li	$v0, 4		# v0 <- system call code for print_string
			la	$a0, newline	# a0 -> newline string
			syscall

			lw	$t0, count	# t0 <- the count
			addi	$t0, $t0, 1
			sw	$t0, count	# count <- count + 1

			li	$t1, 10		# t1 <- max count
			sub	$t0, $t0, $t1	# t0 <- count - max
			blez	$t0, loop	# loop if count <= max

			li	$v0, 10		# v0 <- system call code for exit
			syscall

in assembly, (src) means src is an address and i'm interested in its contents, not itself

int a[10];
i = a[j];

a .word 0, 0, 0...0 // initialize a to array of 0's
la $s0, a
lw $s1, j
s|| (logical shift left) $s1, $s1, 2 // multiplies by 4
add $s2, $0, $s1 // s2 has location of a[j]
lw $s3, 0($s2) (0 bits off s2)
la $s4, i
sw $s3, 0($s4)

4/17/12

TA:

stick to IR structs i have now. 

when in binary expr, don't modify children eg to load their values, just update parent

when loadAddr a, a will be some memory address on the stack (if local) or heap (if global), that's what loadAddr will load.

consider using enums for instruction opcodes?


SPIM:

argc and argv will be put into a0 and a1 registers, but not pushed on the stack. you have to do that manually.

Lecture:

Small optimizations:
	look at as few as 4 instructions at a time
	don't change the semantics at all
	can't have branches
	groups of instructions are called basic blocks
	in a block, a variable is 'live' if its value has been used. a variable is 'killed' if it's overwritten in the block.
	use/def: things you can do with variables
	int i, a[100];
	int i, *p;
	f()
	= a[i]
	= *(a + i)
	= p[i]
	
	b[j] = a[i]
	q[j] = p[i]
	
	to reach def and next use:
	within the basic block, start at the last statement that's "x = y + z" form
	label 
	
4/24/12

TA:

Always cast array to pointer to element type
	in unary expr
	in function parameters
		eg 
		void f(int a[4]) {} -> function, void, [pointer(int)]
		void f(int a[4][5]) {} -> function, void, [pointer(array(4, int))]
The first function has to prepare the stack just like other functions b/c it's called by the OS.
Need a main function to run in SPIM.

Example code generation:

C code:

int add(int a, short b) {
	return a+b;
}

int mult(short a, short b) {
	int c;
	short d;
	c = 0;
	for (d = 0; d< b; d++) {
		int e;
		e = add(c, a);
		c = e;
	}
	return c;
}

Symbol table:

glob
	add (function, int, 2, [int, short])
		a (int), offset 0
		b (short), offset 4
	mult (function, int, 2, [short, short])
		a (short), offset 0
		b (short), offset 2
		c (int), offset 0 (local vars are in a different place than params)
		d (short), offset 4
			for_1
				e (int), offset 8
	allocate 12 bytes for mult (10 for the vars, 2 wasted to align)

IR:

LABEL add (could do mult first too, doesn't matter)
ENTRY add

+
	a (type int, lvalue)
	(int) (type int, not lvalue because just a cast)
		b (short, lvalue)

LA t0, a
LW t1, t0
LA t2, b
LH t3, t2 // also need an unsigned version LHU
// need to cast b into an int, which requires extending the sign bit
CASTSSS t4, t3 // cast signed short to int
ADD t5, t4, t1
RETURN t5

LABEL mult
ENTRY mult

= (int, not lvalue)
	c (int, lvalue)
	0 (int, not lvalue)
	
LA t6, c
LC t7, 0
SW t6, t7
LA t8, d
LC t9, 0
// assigning 0 which is an int to d which is a short, so have to cast 0 to short
CASTSISS t10, t9 // signed int to signed short
SW t8, t10
LABEL for_0
LA t11, d

< (int, rv)
	(int, rv)
		d (short, lv)
	(int)
		b (short, lv)
		
LH t12, t11
CASTSSSI t13, t12

LA t14, b
LH t15, t14
CASTSSSI t16, t15
LESS t17, t13, t16
IFFALSE t17, for_1 // make up label here, insert where it is later
LA t18, a
LH t19, t18
LA t20, c
LW t21, t20
PARAM t19
PARAM t21
CALL add

Lecture:

5/1/12

TA:

In ternary expr, type of expr is a composite type. 
In
 	int a, b[4], c[5];
	a ? b : c
	
	if both b and c are arrays, they're only compatible if at least one doesn't have size. the type will be array of the size of the one that has size.
	
sbrk: system call that sets top of stack, can be used to malloc 

Lecture:

Assertion: done at runtime
Assumption: can't verify at runtime
	eg assumption that no loop carries dependencies so all instructions in all loops can run in parallel
	Without this, there must be an ordering constraint - can't do things in parallel
	
	
