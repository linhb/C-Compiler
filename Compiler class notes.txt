1/31/12

TA section:

Makefile:
scanner.o : scanner.c scanner_token.h : compile from c and h to o

SHould have a driver file for the lex generated file b/c it doesn't have main
also a file that specifies constants
eg  #define CHAR 11

should use a test framework

Lex file:

%option yylineno # keep track of line numbers
%option nounput
%option noyywrap

Top {% %} part:
  include stdlib, errno, string (for copying strings), assert (like java assert)
  if including own file, put in "" no <>

Next part in %% %%: regexes
  eg  newline \n
  can use [[:digit:]], alpha
  {letter}: any letter

Next part:
  {newline}: can do line_number++ or do nothing and let Lex count lines
  
Reserved words
  eg  char  return CHAR # first 'char' is just the regex, 2nd CHAR is from the constants file

When returning the type eg NUMBER, can also set yyval (a static/external variable) to the value of the number, or if returning lots of info about the number, use a struct

strtoul(text, NULL, 10): string to unsigned long, 10 is the base

Can define struct number{ int i} and then have a function that returns number
To declare a variable of type number:
  num = (struct number *)malloc(sizeof(struct number));
To assign value to a struct field: 
  num->overflow = 1;
In the function that finds values of number strings, test by value if they are long or int, signed or unsigned
#define ADDNAME(ARRAY, TOKEN) ARRAY[TOKEN] = #TOKEN # this is a macro that gets the value of TOKEN in the constant file

yylex() returns either a token or 0 -> call repeatedly

Print output with line numbers:
  fprintf(output, "line = %-5d\t", yylineno)

for (token = yylex(); 0 != token; token = yylex())

Output of driver program should be a list of tokens with line numbers, types, values

Example test:
  TEST_F(ScannerTest, SlashTest) {
  fputs("/", test_input);
  fclose(test_input);
  
  EXPECT_EQ(SLASH, yylex()); # expect yylex to return the SLASH token
  }
  
Put this in a separate unit_test file


ssh lbui@nice.harvard.edu

Class

Lexer should return 2 tokens 0 and 1 for input "01"
a ^ b is not the same as (a != 0) ^ (b != 0)
a || is the same as (a != 0) || (b != 0)

Logical operators:
  a && b
  !a
  a || b
  a ? b : c
Bitwise operators:
  a ^ b
  a & b
  a | b
  ~a: complement, reverses bits
Comparison
  a == b
  a != b
  a < b
  a > b
  a <= b
  a >= b
Arithmetic
  +
  -
  * /
  % (remainer not modulo)
  a++
  a--
  ++a
  --a
  -a
Assignment
  =
  +=
  -=
  *=
  /=
  %=
  &=
  |=
  ^=
  >>=
  <<=
Shift
  a >> b (shift a's bits left b times)
  <<
Separator characters
  ()
  []
  {}
  a = b,c,d; # comma is a 'sequence point'
  ;
  :
  …

Can't rewrite a += b as a = a + b because a may have changed, as in:
  a[b++] = a[b++] + c (b will have changed)

Given
  struct node {
    int val;
    struct node *next;
  } myNode;
Then I can say myNode.val

a -> b is equivalent to (*a).b

Forward reference is the ability to reference a symbol earlier in the program text than where that symbol is declared or defined.
  Declaration vs definition:
    Declaration: storage isn't allocated
      eg int f(int x); (prototype declaration; this appears at the top of the file)
      extern int i;
    Definition:
      int f(int x) {
        return x * x;
      }
  Instance where forward reference can happen: 
    in the node struct above where node next* appears before node is done being defined.
    labels:
      void f(void) {
        goto exitCode; # forward reference
        exitCode: ...
      }
Scope: file scope (eg main()), block scope (local variables)
Overloading happens when a later definition overwrites an earlier one, or when 2 functions/operators have the same name eg postincrement and preincrement (both named ++)

Extent: length of time that storage is allocated for that variable
  void f(void) {
    static int i; // this hasn't changed the scope of i, but it changes the extent of i. i now lives for as long as the file lives, but it's still only visible in f. i is initialized to zero because it's static. If I call f recursively, the i in the 2nd f will be this i too. The opposite is auto
    C doesn't allocate and deallocate space for block variables when it enters a block. It figures out how much space the variables in a function needs when it enters the function. It does that by looking at block nesting and figuring out the maximum storage needed. IF there are 2 blocks at the same level, it takes the estimate of one that requires more memory. It also allocates the parameters at the same time.
    
    i = 35; // if you call i after f, it'll be 35
  }
  
static functions:
  static int f(void): can't be seen by other files
  int g(void): can be seen by other files
Type qualifiers
  int *p; // p is a pointer to an int.  This allocates storage for p but not the int that it points to
  p = &i; // p gets the address of i
  *p = 3; // changes what p points to
  If we have
    const int *p1; // p1 is a pointer to constant, so can't say *p1= but can say p1 =
    int * const p2; // p2 is a constant pointer to an int, so can't say p2 = … but can say *p2 = 
    const int * const p3; // p3 is a constant pointer to a constant int 

There are 5 classes of identifiers
  macros
  labels: can have the same name as a variable because it's only used after goto
  tags: what follows struct, union and enum eg the 'node' in 'struct node', also can be the same as variables
  component names: fields in structs and unions eg val in struct node above
  all other names: variables, functions, typedef names, enum constants. Every one of these requires creating a new symbol table

main isn't a reserved word; it's just a requirement of the linker


Regular expressions
  sigma: alphabet
  epsilon: a regex
  L(epsilon): language accepted by epsilon which is {epsilon}
  a is a symbol in the alphabet
    a is a regex
    L(a) = {a} 
  (r) | (s)
    L(r) union L(s)
  (r)(s)
    L(r)L(s): strings accepted by r concatenated with strings accepted by s
  (r)* 
    L(r)*
  * is idempotent: you can apply it multiple times and it'll just be like applying it once
  Ex: {letter}({letter}|{digit})*/[^a-zA-Z0-9]
  things after the slash are required to be present but aren't part of the symbol, so characters that aren't a-z, A-Z, 0-9 must follow the string but aren't part of the string
  <Fig. 1>
  
Lex
  Special characters
    ^: NOT and beginning of line
    $: end of line
    /: must be followed by
  Rules
    c matches the single no-operator character c
    \c matches the character c
    [^s]: matches any one character not in s
    r{m, n}: matches between m and n occurrences of r
    (r) matches r where r is a regex
    {name} matches the regex defined by name
  Extension .lex
  Format
    <definitions>
    %%
    <rules>
    %%
    <user functions>
  Anything in definitions section that's delimited by a line with %{}% is copied directly to the C output
  Definition section: each line has format <name><regex>. MUST NOT HAVE SPACE BEFORE REGEX!
  The kind of token gets returned
    Things with the same precedence can be returned together eg multiplicative_operator
  The value of the token gets placed in yylval
  
  
  Compiling a Lex file
    lex lexer.lex
    gcc lex.yy.c -c // -c means create an object file, but don't link
      object file will have .o extension
      returns lex.yy.o
    gcc -pedantic -Wall lex.yy.o lexer.c -lfl -o lexer
      pedantic means ensure standard compliance
      Wall: issue all warnings
      lfl: link with the flex libraries
  Special symbols (mostly for use with yacc):
    yytext: the matched string as a null terminated string
    yyleng: length of yytext
    yylex(): name of generated lexer function
    yylval: value of the token returned
      What type should it be? struct or union if needed
  Sample Makefile on course website
  Lex always prefers longer string match to resolve ambiguity
  If 2 matches match strings of the same length, Lex will pick the one that comes earlier in the .lex file
  
lvalue and rvalue: when you have eg int a = 3, there are 2 relevant values, 3 and a's memory address
  lvalue is the memory address, retrieved with &
  rvalue is the value 3, retrieved with *

#define is a preprocessor
union: like struct in most ways except can only call 1 field at a time (they're stored at the same address). Good for variables whose value can only be 1 of several types.

&: address-of operator (mnemonic: address-ampersand)

strcmp(str1, str2) returns 0 if the strings are equal, 1 if str1 is lexically larger (alphabetically behind) str2, -1 otherwise

2/7/12
TA section:
yylex() must return all info asked for

At the very end of rule definitions in lexer.l, can do
	.	return -1;
	This will catch every token that didn't match any above, then you can test if token < 0 to output errors

Treat everything strictly according to their appearance eg star, not what they could mean.

Identifier limit 31
String: just check memory was successfully allocated
Should return a unique number for every operator
Make int and long different tokens based on rule: it's the first type that it fits in this list: int, long, unsigned long

Have make clean target

make clean before submitting

Run script in hw1 directory, do some manual testing, Ctrl D when done

Submitting:
	submit libe295 1 <absolute path to hw directory eg ~/hw1>
	
Don't submit irrelevant files like .git

Can submit multiple times.

Add token type for comments

Lecture:

Problem set 2:

Lex program that works with YACC:
	
Goal: build a tree
	output must look like input but with treelike annotations, as proof that parser parsed the input and formed a tree
	no need to build symbol table
	just make a copy of every string you find
	things that belong to the language should be abstracted into a node
	only things the user specifies should be made strings (identifiers, etc)
	If no signed modifier, assume signed
	void can be return type or parameter, no void pointers
	no pointer to functions
	function can either always return something or implicitly return int when not specified
	no declarations without definitions except function prototypes. Prototype param list doesn't need to resemble actual signature.
	must have any level of pointers, any dimension of arrays
	should say approx line number 
	variables can only be defined once, at any scope, except functions which can have prototypes

Example of tree:
	main() {
		int lhs, alpha, beta, gamma;
		lhs = alpha + beta * gamma;
	}
	<Fig. 2>

+ and * nodes don't have to be different kinds of nodes if you specify the precedence

There's a grammar on the website that can be parsed into a grammar

Don't have every production as a node

YACC format:

<declarations>
%%
<translation rules>
%%
<supporting C functions>

<declarations> have all the constants currently in token_constants.h
	everything between %{ and %} is copied into output, so should have prototypes for supporting functions
	Each line in declarations
		%start <nonterminal>
		%token <listOfNames> // list of tokens having the same precedence
		%left <listOfTerminals>
		%right <listOfTerminals>
		%nonassoc <listOfTerminals>
	Precedence: in order of declaration, lowest first
	Translation rules:
		<head>	:	<body1> {<semantic action 1>}
						| <body2> {<semantic action 2>}
						;
	single quoted char is terminal symbol
	$$: attribute associated with head
	$i: attribute of ith symbol
	unquoted strings not declared to be tokens are nonterminals
	in reduce conflict, 1st one listed wins
	shift wins over reduction
	tries to take care of as many tokens as possible
	default precedence of a production is that of its rightmost terminal
	
	#include lex.yy.c in 3rd part of Yacc file ()
	the tokens in the yacc file actually get declared first, before lex
	
	DIfference from standalone version of lexer:
		YYSTYPE: macro indicating the type you want yylval to be
		struct node: have fields for all types of info the nodes should have, enum type, *operator, node *left, *right, int val. Nodes will need to say the base type of pointers for later type checking.
		have print_tree function
	Translation rules
		a : b: a can be rewritten as b
		More rules => less precedence to worry about and vice versa
	Output: has node type, addresses of children so we can reconstruct the tree
Dragon app for recording?     c
How to tell if i have an expr if the rule for expr is expr + term | term
	Yacc tries to match the longest string
	a method that looks for expr will look for it first thing every time it calls itself, so it'll recurse forever, hence 'left recursive' language
	look at rule for factor: (expr) | number -> if doesn't start with ( or number, not a factor
	To avoid left recursion, 
		if a: a | b
		rewrite:
		a: b a'
		a': a a' | epsilon
		This however doesn't produce a correctly balanced tree as in Figs 3, 4. In Fig 4, the tree is right associative, while the language is left associative
		
2/14/12
TA section
Pretty printer
	basically print source program but with indentation and parens around everything that can use parens (required)
	regularize indentation
	parenthesize everything
	print escape sequences 
	to print binary ops: print ( then left operand then space then right operand then )
	can have all the parens you want especially to clarify precedence
	good test: feed program in, get output, put output in, should get itself
	all functions take int indent, increment whenever you enter new scope
	can use phpsyntaxtree to visualize
main functions is the same as lexer
	call yyparse, get 1 value
	yyparse sets yynerrs
	if >0, set result to 1
parser
	yystype is node*
	default action is $$ = $1 (the thing returns from the first symbol)
	example of non default: left_paren expr right_paren: $$ = $2
	global var root_node so you can get it back
	$$ is yylval?
	can use union type for node, can be number, identifier etc, each of which is a struct with specific fields. These can be defined in node.h
	the actions create node*'s
	the specific node creators call create_node to malloc
statement_list node: has 2 children, left one expands into the another statement_list and the 3rd from last statement, etc. Then you traverse the node recursively to print. one of the bottom statement_list nodes will have NULL as a child because it only contained 1 statement
	yylval is what was returned by yylex(), so when you assign the value of a terminal to the value of a production ($$), $$ will end up being the same as yylval. $$ and yylval do have to be the same type.
error
	error production: error SEMICOLON -> means if you see error, keep scanning until you see a semicolon. If you don't have this production, the parser will exit when it gets an error.
	Bison knows that if lex returns -1, it's an error
	implement yyerror(char *msg) which Bison calls automatically when it gets an error
epsilon: 
	pass NULL to creator function eg parse.y:59
statement vs expression:
	statement can have operators, can be an expression
compound statement = block

Lecture

Updated PS1 and HTML grammar
Recursive descent = top down = predictive

Predictive parsing: 
	2 important functions: first and follow
Generate NFA   from regex:
	ba*b(a|b)a
	Fig 5                             
	epsilon-closure(state): all possible states you can be from state based on transitions alone
	epsilon-closure(set of states): union of ES of each state in the set
	If building algo to find ES, have to keep a set of states to check for epsilon paths coming out of them, because some results can be reached with >2 epsilon transitions
Build DFA from NFA:
	notebook
How parsers work
	notebook  
Generating grammars
	ba*bba
		Ao => bA1bba
		A1 => aA1 | epsilon # basically break down parts of the regex that aren't static into rules
	if (if...() endif) endif
		so => if S1 endif S1
		S1 => S0 | epsilon
		Not possible with regex
	stmt -> if expr then stmt |
					if expr then stmt else stmt |
					other
		ambiguous eg if e1 then if e2 then s1 else s2
		Fix:
			stmt -> matched-stmt | open-stmt
			ms -> if e then m-s else m-s | other
			o-s -> if e then stmt |
						 if e then m-s else o-s # this says only m-s can be between if and then, and m-s is defined above to have else bound to the correct if
Fixing recursive productions:
	notebook

First and follow functions
	Non left recursive grammar for + and *:
		E -> TE'
		E' -> + TE' | epsilon
		T -> FT'
		T' -> * FT' | epsilon
		F -> (E) | id
	first(alpha): set of terminals that can appear as the first token in alpha. Can include epsilon
		if X -> Y1Y2...Yk
			then first(X) will include first(Y1)
			if first(Y1) includes epsilon then first(X) includes first(Y2) (makes sense b/c that means Y1 can disappear leaving Y2 at the top)
 	follow(nonterm): set of terminals that can follow any sentence derived from nonterm
		useful for error recovery: can look for a symbol in follow if error found, thus terminating erroneous string
		the follow set for the start symbol should always include the endmarker $ because it definitely follows the topmost nonterminal
	
	alpha	first(alpha)	follow(A)
	+    	{+}
	*    	{*}
	(    	{(}
	)    	{)}
	id   	{id}
	---
	E    	{(, id}	    	{), $}
	E'   	{+, epsilon}	{), $}
	T    	{(, id}     	{+, ), $} # everything in first(E') except epsilon should be in follow(T) because E' follows T
	T'   	{*, epsilon}	{+, ), $}
	F    	{(, id}     	{*, +, ), $} 
	
Now we can automatically construct a recursive descent parser:
	LL(1) grammars:
		L1: left to right
		L2: leftmost derivation
		1: token of lookahead
	Build predictive parsing table M:
		Grammar again, numbered:
			E -> TE' (1)
			E' -> + TE'	(2) | epsilon (3)
			T -> FT' (4)
			T' -> * FT' (5) | epsilon (6)
			F -> (E) (7) | id (8)
			
		
		Nonterm 	id			+   			*			(					)							$
		E	      	E->TE'						 			E->TE'
		E'      					E->+TE										E'->epsilon   E'->epsilon
		T	      	T->FT'						 			T->FT'
		T'      					T'->eps		T'->*FT'				T'->eps				T'->eps
		F	      	F->id 						 			F->(E)
		
		Example: (id + id) * id + id $
		Looking for E, see (, look into table at E and (, 
		
		Matched			Stack				Input								Action
		            E$        	(id+id)*id+id$
		            TE'$     	 	''                  E->TE'
		            FT'E'$   	 	''                  T->FT'
		            (E)T'E'$ 	 	''                  F->(E)
		(           E)T'E'$	 	 	id+id)*id+id$				match (
		            TE')T'E'$	 	''                  E->TE'
		            FT'E')T'E'$ ''                T->FT'
		            idT'E')T'E'$ ''               F->id
		(id         T'E')T'E'$ 	+id)*id+id$        match id
		            E')T'E'$    ''                T->eps
		            +TE')T'E'$  ''                E'->+TE'
		(id+        TE')T'E'$   id)*id+id$        match +
		            FT'E')T'E'$ ''                T->FT'
		            idT'E')T'E'$ ''               F->id
		(id+id      T'E')T'E'$  )*id+id$          match id
		            E')T'E'$    ''                T'->eps
		            )T'E'$      ''                E'->eps
		(id+id)			T'E'$       *id+id$           match )
		            *FT'E'$     ''                T'->*FT'
		(id+id)*    FT'E'$      id+id$            match *
		            idT'E'$     ''                F->id
		(id+id)*id  T'E'$       +id$              match id
		            E'$         ''                T'->eps
		            +TE$        ''                E->+TE
		(id+id)*id+ TE$         id$               match +
		            FT'E$        ''               T->FT'
		            idT'E$       ''               F->id
		(id+id)*id+id T'E$          $             match id
		            E$                            T'->eps
		            $                             E'->eps
		
2/21/12

TA section:

can declare error at the statement level

How to escape strings:
input "hello\n"
should convert into char array {'h', 'e', 'l', 'l', 'o', 10, 0} where 10 is the ASCII code for \n

Lecture:

Types:
	generate a symbol table for each scope
	All identifiers in the parse tree must be replaced with the right pointer into the symbol table
	A C type can be integral, floating-point, pointer, array, structure, union, function or void type.
	Integral and FP are arithmetic and scalar. Pointer is scalar.
	Array and structure are aggregate
	Symbol table:
		type		variable
		int			i
		int			j
	int pointers will have a type of pointer that points to the base type int
	& creates a pointer variable
	Pointers can be object, function or void pointers
	void * is a generic pointer which can't be dereferenced unless it's cast
	null pointer is equiv. to the integer constant 0
	Array type representation: number of elements field, base type field
	Note: arrays are really a pointer of the type of its elements, so if you say int p = A p actually gets the memory address of A's first element.
	Exception: sizeof(A) gives the actual array size. So you can get the size of A by sizeof(A) / sizeof(A.length)
	&A is the same as A
	Arrays can be any type except void, incomplete type (not done defining), function type
	always have 0 origin
	Multidimensional arrays are stored in row-major order (adjacent elements in memory differ by 1 in their LAST subscript) 
		eg: int A[2][3]: the whole thing, all 6 ints, have to be stored contiguously
		A is stored as 2 arrays of 3 ints each
		Memory layout of A:
			k			A[0][0]
			k+4		A[0][1]
			k+8		A[0][2]
			k+12	A[1][0]
			k+16	A[1][1]
			k+20	A[1][2]
	The subscript operator has the highest precedence
	A[k] is the same as *(A+k)
	Conversion of array to pointer happens for multidimensional arrays as for singly dimensioned arrays, but only for hte top level array-ness
	A = T[i][j][k] is converted to a pointer to T[j][k]
	
	enum types: integer values represented by identifiers
		type int
		ex: enum boats {power, sail, finghy} boat1, boat2;
	struct
		We can refer to struct node within struct node because pointers are allowed to refer to incomplete types 
		ints in structs have to be on addresses that are multiples of 4, etc, (aka alignment), so structs may contain holes in their storage allocations.
		components are laid out in the order they're specified
		bit fields may be specified for components in structs:
			structs DiskReg {
				int ready:1; // now ready can only occupy 1 bit so it can only be 0 or 1
				int error:1;
				int track:9; // track can be between 1 and 511
			}
	union
		storage is allocated for all components starting at the beginning of the union, so all components have the same address as the union
		If you define a field then access another field, there's no telling what you'll get back?
		vs casting:
			myStruct.f = 3.14;
			i = myStruct.i; // gets 4 bytes from the address of myStruct.f and make it an int, equiv to *(int *)&f
			i = (int) myStruct.f; // this will truncate the value so you'll get 3
	function
		can't return arrays or functions, but can return pointers to arrays and functions
	minimum precisions:
		char: 8 bits, etc
	integral number representation:
		integers:
			unsigned: 
			4 ways to represent sign:
				sign and magnitude: if having 16 bits
					1st bit: sign, 0 = pos, 1 = neg
					other 15 bits: 0 to 2^15 - 1
					value = -1^sign bit * 15 bits
					problem: 
						2 representations for 0, eg 0000 and 1000 for 4 bits
						numbers don't go in counting order: 1111 is -7, 0111 is 7, which means adding 1 is tricky: 
							1001 is -1, 1010 is -2, so to go from -1 to -2 you have to add 1
				one's complement
					the negative version of a number is its bitwise complement
					eg 0111 is 7, 1000 is -7
					can now add numbers the same way for + and - numbers
					problem: 
						still 2 values for 0: 0000 and 1111
				two's complement
					to get the negative version, complement the number then add 1
					thus the most significant bit is 1 for negative, = for positive
					eg: 1 is 0001, -1 is 1110+1 = 1111. This works both ways: ~(1111)+1 = 0001
					now the negative of 0 is ~(0000)+1 = 0000
				excess notation
					if you want a lot of positive numbers, pick a bias, eg with 4 bits, pick a bias of 4. Now 0 is represented as -4, 1 as -3, etc. This way you can have numbers from 4 to 15 while the representation is 0 to 11.
		floating point numbers
			s	sign bit (0 for positive, 1 for negative)
			b	base/radix
			e	exponent value: excess notation number
			p	number of base-b digits in the significand
			f(k): significand digits
			x = 
			eg: 
			
2/28/12

TA section

% expect 1 tells the parser to expect 1 shift/reduce conflict so the error will be suppressed

Ex 4.6.2 (p258)
First(S) = {a}
Follow(S) = {a, +, *, $}
I0: closure of starting symbol
	S' -> .S
	S -> .SS+
	S -> .SS*
	S -> .a
	| a (on input a)            |
	v                           v
I2:                        I1:
	S -> a.                    S' -> S.          $
                     <--     S -> S.S+         -> accept
                      a      S -> S.S*
                              | S
                              v
												I3   S -> SS.+                +
				                     S -> SS.*  <__           -> I4: S -> SS+.
														 S -> S.S+    |  S        *
				                     S -> S.S*  ---           -> I5: S -> SS*.
														 S -> .SS+
				                     S -> .SS*                               

Fig 6 (small notebook)

Type tree for functions: Fig 7 

Must be able to indicate the declared type is different from the real type.

Lecture

if same identifier with different names, can print memory address or anything to show they're the same.

Can print the original declaration with comments showing its row in the symbol table

int glob_i; // symbol table here, must have glob_i and f
void f(int param) {  // symbol table here, must have 2 entries, for the function and the int. basically block scope with the function
	int func_i;
	{
		int block_i; // symbol table here with only 1 entry
	}
}

The data structure can be anything that lets you access all the info you need.  
No need to make sure subsequent entries are at higher memory addresses.

Type tree example: Fig 8
                                                                            
You can remove all terminals.                                                        
There'll be only 1 int and 1 void that all instances in the tables point to.

PS4: add casts
	int i;
	char c;
	i = c;
	in PS3, pretty print that as (i = c);
	in PS4, (i = ((int)c));  May need more than 1 cast 

Errors must now ?
Must catch duplicate declaration.
Must show which symbol table the identifier is bound to.

By PS4 all errors must have come out.

How to represent numbers:
	13
		-1^0 * 1.101 * 2^3
		010000010101...0(20 zeros)
	1.625
		-1^0 * 1.101 * 2^0
		0011111111010..0(20 zeros)

Another shift-reduce example: Fig 9                    

Unary conversion: keep them signed if possible (if the values are small enough) (according to HS p197)
	unsigned short us;
	us = 0;
	if (us < -7) {} // us will be converted to int

int * const p1;
const int *p2; 
p1 = p2 //no
p2 = p1 //yes

3/6/12

Note: labels can have the same name as another variable in the same function, so must create a separate ST at function level for labels

Should add field in identifier struct that contains pointer to ST entry

Create child ST whenever sees compound statement   

Children must have pointer to parent so you can access global vars from blocks

Input:
	int a;
	char *b;
	long z[5];
	int main(int argc, char *argv[]);
	void c(void) {
		char a;
		for (a = 0; a < 5; a++) {
			long c;
			c = z[a];
		}
	}

	Create global ST: global
		map from names to symbols, which have name, type
		list of child symbol tables
		
		Sample output:
		
		global
			symbols
				a -> {a, 1, int}
				b -> {b, 2, pointer(char)}
				z -> {z, 3, array(5, long)}
				main -> {main, 4, func(int, 2, [int, array(?, pointer(char))])}
				f -> {f, 5, func(void, 0, [])}
			children
				f
					symbols
						a -> {a, 6, char}
					labels
						inside -> {inside, 8, b = 0 (basically pointer to the statement, print as "line 10")}
					children
						block1
							symbols
								c -> {c, 7, long}
		Also, when printing parse tree, instead of printing 'int a', print:
			int a /* symbol 1 */
			int b /* symbol 2 */
			c /* symbol 7 */ = z /* symbol 3 */[a /* symbol 6 */]
			
Errors I have to declare: 
	undeclared variable: must go all the way up to global ST, then declare error, then keep walking the tree, BUT DON'T PRINT IT			
	don't have to check if prototype doesn't match function signature
	something like int f(void, int argc);
	void x (but void *x is ok!)

If function has arguments, have to enter them in ST too

Lecture

Midterm: up to chapter 7, more emphasis on earlier stuff, no chapter 6

Memory management:
	Allocate memory at function entry, deallocate at function exit -> there is shared memory
		int glob_i, glob_j;
		int f(float param_f) {
			int i;
			{
				int j;
			}
			{
				int k;  // k shares the same memory as j, which is ok because their lifetimes don't overlap
			}
		}
		void g(long l) {
		
		}
Stacks:
	'top of stack' is actually the lower memory
	the lowest memory  memory is for the program, aka 'text' as opposed to data
	next level is static/data segment: global variables
	next is heap storage eg malloc, new, etc
	
Stack frame:
	void main(void) {
		f(3.14f);
	}
	
	When main is running and about to call f, first evaluate the parameters, which is 3.14. 
	
	low			
	        callee saved registers
					temporaries                                                                              <-- stack frame
	        local vars
	        return address, which is a pointer into the program
	        link to old frame pointer (FP) which contains the address of the frame that current function is called from (so main's FP is null)
	        saved registers by caller
	        return int
	        3.14f
	high		

How to know how much memory to allocate: look at all the symbol tables for that level and down. If >=2 blocks at same level, take the max
The FP is offset 0. If local vars take up eg 12 bytes, they'll be eg offset -8 to -15.
If language allows functions inside functions, the stack frame can be adjusted:
	add a pointer called 'access link' into the bottom level function stack frame that points to the FP of the parent function
	
Heap management
	Heap:
		heap and stack grow toward each other: heap grow higher, stack grows lower
		allocation is arbitrary
		static
			eg addr = malloc(bytes)
			free(addr) // doesn't guarantee memory is actually freed
			You can have alternating spaces that are allocated and free which means no space for big objects
			can't just compress by moving everything to lower addresses b/c the memory chunks may contain their own address 
			To allocate, can look through free chunks to find lowest size chunk that fits (best fit) but this is bad b/c ?
			worst fit (largest chunk left over) is better b/c another big allocation can be made from the leftovers
			first fit: first chunk that fits
			next fit: next chunk from last allocation
Automatic allocation:
	Reference count model: every time you create a pointer, it counts how many things point to it. When count == 0, system frees it
	Garbage collection: recursively 'reach' every object. anything not reached is cleaned up.
	Compaction: move stuff to lower spaces
Assembly language:
	32 registers, 0 to 31
	register 0 is the constant 0 (can't save to it)
	uses three-address code -> can save to R0 if don't need to save result of operation
	some instructions are pseudo (not hardware) instructions eg 'neg'
	v0, v1 can store results of functions where they fit in 2 registers
	a0-a3: arguments
	t1-t7: temporary (saved by callee), reserved across calls
	s0-s7: saved temporary (saved by caller), not reserved across calls
	stack pointer
	frame pointer
	return address
	Format of the add operation:
	add rd, rs, rt
		000000 rs rt rd 00000 100000 (ADD)
		  6    5   5  5   5     6
		31                         0
	addi
		001000 rs rt immed
	lw rt, off(base)
		100011 base rt offset